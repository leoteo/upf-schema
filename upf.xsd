<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">

  <!-- Definition of elements -->

  <xs:element name="UPF">
    <xs:annotation>
      <xs:documentation>Root section</xs:documentation> 
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="PP_INFO" minOccurs="0"/>
        <xs:element ref="PP_HEADER"/>
        <xs:element ref="PP_MESH"/>
        <xs:element ref="PP_NLCC" minOccurs="0"/>
        <xs:element ref="PP_LOCAL"/>
        <xs:element ref="PP_NONLOCAL"/>
        <xs:element ref="PP_PSWFC"/>
        <xs:element ref="PP_RHOATOM"/>
      </xs:sequence>
      <xs:attribute name="version" use="required" type="upf-version-string"/>
    </xs:complexType>
  </xs:element>

  <xs:element name="PP_INFO" type="xs:string">
    <xs:annotation>
      <xs:documentation>
        For human-readable data (ignored by QE).
      </xs:documentation> 
    </xs:annotation>
  </xs:element>

  <xs:element name="PP_HEADER">
    <xs:annotation>
      <xs:documentation>
        Machine-readable minimal data on the pseudopotential.
      </xs:documentation> 
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name="element" use="required" type="upf-element">
        <xs:annotation>
          <xs:documentation>Element symbol</xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="generated" use="optional" type="upf-string">
        <xs:annotation>
          <xs:documentation>Software used to generate the pseudopotential
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="author" use="optional" type="upf-string"
                                                 default="anonymous">
        <xs:annotation>
          <xs:documentation>Author of pseudopotential</xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="date" use="optional">
        <xs:annotation>
          <xs:documentation>Generation date</xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="comment" use="optional" type="upf-longstring"/>

      <xs:attribute name="pseudo_type" use="required" type="upf-pseudotype">
        <xs:annotation>
          <xs:documentation>
            Pseudopotential type (not used by the software, 
            human-readable alias)
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="relativistic" use="required" type="upf-relativistic-type">
        <xs:annotation>
          <xs:documentation>
            Level of relativistic formalism used in atomic calculation
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="is_ultrasoft" use="required" type="upf-logical">
        <xs:annotation>
          <xs:documentation>
            True if pseudopotential is ultrasoft or PAW, 
            i.e. if it has augmentation/compensation charge
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="is_paw" use="required" type="upf-logical">
        <xs:annotation>
          <xs:documentation>
            True if pseudopotential is actually a PAW dataset
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="is_coulomb" use="optional" type="upf-logical" 
                    default=".false.">
        <xs:annotation>
          <xs:documentation>
            True if pseudopotential is a Coulombian 1/r potential
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="has_so" use="optional" type="upf-logical" 
                    default=".false.">
        <xs:annotation>
          <xs:documentation>
            True if spin-orbit information is present.
            In this case, the PP_SPIN_ORB section must be present.
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="has_gipaw" use="optional" type="upf-logical"
                    default=".false.">
        <xs:annotation>
          <xs:documentation>
            True if additional information for GIPAW reconstruction is
            present. In this case, the PP_GIPAW section must be present.
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="core_correction" use="required" type="upf-logical">
        <xs:annotation>
          <xs:documentation>
            True if the pseudopotential contains pseudized core charge
            for non-linear core.
            In this case, the PP_NLCC section must be present.
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="functional" use="required" type="upf-shortstring">
        <xs:annotation>
          <xs:documentation>
            Short-name for the DFT functional used.
            It can either be an alias (such as PBE, LDA) or specify in order:
            functional for exchange, functional for corellation,
            gradient correction for exchange, gradient correction for corellation.
            E.g. PBE is 'SLA PW PBX PBC'. 
            The list of short-names understood by QE is listed at the beginning
            of file Modules/functional.f90 in its source tree.
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="z_valence" use="required" type="xs:double">
        <xs:annotation>
          <xs:documentation>
            Valence charge (atomic number - core charge) in units of
            abs(electron charge). This will usually coincide with the
            number of valence electrons.
            If the pseudopotential has been generated with a charged 
            configuration, z_valence will *not* be affected, but the sum
            of the occupations will not match this value.
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="total_psenergy" use="optional" type="xs:double"
                    default="0.0">
        <xs:annotation>
          <xs:documentation>
            Pseudopotential energy of the configuration used 
            for the pseudopotential configuration (Ry)
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="wfc_cutoff" use="optional" type="xs:double"
                    default="0.0">
        <xs:annotation>
          <xs:documentation>
            Suggested plane wave cutoff (Ry)
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="rho_cutoff" use="optional" type="xs:double"
                    default="0.0">
        <xs:annotation>
          <xs:documentation>
            Suggested charge density cutoff (Ry)
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="l_max" use="required" type="xs:integer">
        <xs:annotation>
          <xs:documentation>
            Maximum angular momentum of a valence orbital.
            !!CHECK!! if the local channel has the maximum angular momentum, 
            and it is not empty, is it counted here or not? 
            Would it have any effect if it is wrong?
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="l_max_rho" use="required" type="xs:integer">
        <xs:annotation>
          <xs:documentation>
            Maximum angular momentum of atomic charge density,
            should be 2*l_max.
            !!CHECK!! same as l_max
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="l_local" use="optional" type="xs:integer">
        <xs:annotation>
          <xs:documentation>
            If local potential was generated by inversion of a norm-conserving
            wave function, then l_local is equal to the l of this channel.
            If the local potential was generated by some other means,
            e.g. smoothing the all-electron potential, then l_local &lt; 0.
            The atomic code in QE uses l_local=-1, if the smoothing was done
            with two Bessel functions (RRKJ optimized)
            and l_local=-2, of it was done with the Troullier-Martins recipe.
            Note that the local potential always has spherical symmetry.

            This attribute is actually unused in the plane-wave code
            (stored only for reconstruction purposes).
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="mesh_size" use="required" type="xs:integer">
        <xs:annotation>
          <xs:documentation>
            Number of points in the radial grid, on which potential,
            wave functions and other quantities are stored.

            Note: the number of mesh points for the potential and the 
            wave functions may in principle be different. This is not
            allowed in the UPF 2.0.1 format.
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="number_of_wfc" use="required" type="xs:integer">
        <xs:annotation>
          <xs:documentation>
            Number of wave functions stored in the file.
            These wave functions are used by QE programs only to bootstrap
            self-consistency.

            Note: In the PAW case, these are *not* the wave functions used
            for the one-center terms. They are used ONLY to generate the
            initial charge density to bootstrap the self-consistent cycle.
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="number_of_proj" use="required" type="xs:integer">
        <xs:annotation>
          <xs:documentation>
            Number of Kleinman-Bylander projectors in the pseudopotential.
            In the PAW formalism, this is also the number of wavefunctions
            used in one-center terms. Many other quantities, e.g. the number
            of augmentation channels, depend on the value of number_of_proj.
            If the pseudopotential has no projectors, number_of_proj must be
            set to zero.
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="has_wfc" use="required" type="xs:NCName">
        <xs:annotation>
          <xs:documentation>
            Deprecated??
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="paw_as_gipaw" use="required" type="xs:NCName">
        <xs:annotation>
          <xs:documentation>
            Deprecated??
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:element name="PP_MESH">
    <xs:annotation>
      <xs:documentation>
        Defines the mesh.
      </xs:documentation> 
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="PP_R"/>
        <xs:element ref="PP_RAB"/>
      </xs:sequence>

      <xs:attribute name="dx" use="optional" type="xs:double">
        <xs:annotation>
          <xs:documentation>
            r(i) = exp ( xmin + (i-1) dx ) / zmesh i=1,mesh
            r_ab(i) = r(i) * dx
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="xmin" use="optional" type="xs:double">
        <xs:annotation>
          <xs:documentation>
            r(i) = exp ( xmin + (i-1) dx ) / zmesh i=1,mesh
            r_ab(i) = r(i) * dx
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="zmesh" use="optional" type="xs:double">
        <xs:annotation>
          <xs:documentation>
            r(i) = exp ( xmin + (i-1) dx ) / zmesh i=1,mesh
            r_ab(i) = r(i) * dx
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="mesh" use="optional" type="xs:integer">
        <xs:annotation>
          <xs:documentation>
            Deprecated. Use mesh_size in PP_HEADER instead.
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="rmax" use="required" type="xs:double">
        <xs:annotation>
          <xs:documentation>
            Deprecated??
          </xs:documentation> 
        </xs:annotation>
      </xs:attribute>

    </xs:complexType>
  </xs:element>

  <xs:element name="PP_R" type="upf-data-section">
    <xs:annotation>
      <xs:documentation>
        Data section containing the radial grid,
        on which quantities such as local potential,
        wave functions, projectors and augmentation charges are sampled.
        The ith value of these quantities corresponds to the ith
        element of the radial grid.
      </xs:documentation> 
    </xs:annotation>
    <!--    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="upf-list-of-doubles">
          <xs:attribute name="type" use="required" type="xs:NCName"/>
          <xs:attribute name="size" use="required" type="xs:integer"/>
          <xs:attribute name="columns" use="required" type="xs:integer"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
-->
  </xs:element>

  <xs:element name="PP_RAB" type="upf-data-section">
    <xs:annotation>
      <xs:documentation>
        Data section containing the radial volume element.
        These attributes have been used to generate the logarithmic grid on
        which the pseudopotential is constructed.
        The expression insode the atomic code of QE is:
          r(i) = exp ( xmin + (i-1) dx ) / zmesh i=1,mesh
          r_ab(i) = r(i) * dx
        For PAW, this is the only acceptable grid (required in V_H).
        Otherwise, any kind of grid is accepted, if it can be used to compute
        a Simpson numerical integral according to the formula
          \sum_i c_i f(i)*rab(i) = \int_0^\infty f_i dr
        where c_i are alternativly 2/3 and 4/3, except c_1=c_mesh=1/3.
        f_i is a generic function, such as the atomic wave function, sampled on
        the grid r(i): f_i = f(r_i). An equivalent definition of rab is
          rab(i) = dr(x) / dx | x= i
      </xs:documentation> 
    </xs:annotation>
  </xs:element>

  <xs:element name="PP_NLCC" type="upf-data-section">
    <xs:annotation>
      <xs:documentation>
        Data section containing the pseudized core charge
        used for non-linear core correction
        sampled on the radial grid stored in PP_R.
        It is the true charge density, i.e. it will be 
        correctly integrated as
          \sum_i 4 \pi r_i^2 nlcc_i

        Ignored if core_correction is false.
      </xs:documentation> 
    </xs:annotation>
  </xs:element>

  <xs:element name="PP_LOCAL" type="upf-data-section">
    <xs:annotation>
      <xs:documentation>
        Data section containing the local potential sampled in the radial grid
        (Ry). The potential does not contain the effect of the net valence charge
        (-e2*z_valence/r_i), which will be added directly in the plane-wave code.

        Igonred if is_coulomb (PP_HEADER).
      </xs:documentation> 
    </xs:annotation>
  </xs:element>


  <xs:element name="PP_NONLOCAL">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="PP_BETA.1" minOccurs="0" maxOccurs="1"
                    type="upf-PP_BETA.n"/>
        <xs:element ref="PP_DIJ"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:complexType name="upf-PP_BETA.n" mixed="true">
    <xs:attribute name="index" use="optional" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          For PP_BETA.n, this is just n.
          
          TODO do away with the PP_BETA.n naming scheme.
        </xs:documentation> 
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="angular_momentum" use="required" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          The angular momentum of the projector.
        </xs:documentation> 
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cutoff_radius_index" use="optional" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          The projector is assumed to be zero beyond this point.
          If it is not specified, it is assumed to be equal to the mesh size.
          
          NOTE: Not specifying cutoff_radius can introduce a considerable
          numerical noise in some integrals, especially in the PAW case.
        </xs:documentation> 
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cutoff_radius" use="optional" type="xs:double">
      <xs:annotation>
        <xs:documentation>
          The value of the radial mesh point corresponding to cutoff_radius_index.
          This value is currently unused in the plane-wave code.
        </xs:documentation> 
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="norm_conserving_radius" use="optional" type="xs:double">
      <xs:annotation>
        <xs:documentation>
          Value of norm conserving wave function used to generate the 
          ultrasoft pseudopotential. 
          Ununsed in the code, stored only for reconstruction purposes,
          meaningless for PAW.
        </xs:documentation> 
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ultrasoft_cutoff_radius" use="required" type="xs:double">
      <xs:annotation>
        <xs:documentation>
          UNDOCUMENTED
        </xs:documentation> 
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="label" use="required" type="xs:NMTOKEN">
      <xs:annotation>
        <xs:documentation>
          UNDOCUMENTED
        </xs:documentation> 
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="columns" use="required" type="xs:integer"/>
    <xs:attribute name="size" use="required" type="xs:integer"/>
    <xs:attribute name="type" use="required" type="xs:NCName"/>
  </xs:complexType>

  <xs:element name="PP_DIJ">
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:double">
          <xs:attribute name="columns" use="required" type="xs:integer"/>
          <xs:attribute name="size" use="required" type="xs:integer"/>
          <xs:attribute name="type" use="required" type="xs:NCName"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="PP_PSWFC">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="PP_CHI.1"/>
        <xs:element ref="PP_CHI.2"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="PP_CHI.1">
    <xs:complexType mixed="true">
      <xs:attribute name="columns" use="required" type="xs:integer"/>
      <xs:attribute name="cutoff_radius" use="required" type="xs:double"/>
      <xs:attribute name="index" use="required" type="xs:integer"/>
      <xs:attribute name="l" use="required" type="xs:integer"/>
      <xs:attribute name="label" use="required" type="xs:NMTOKEN"/>
      <xs:attribute name="n" use="required" type="xs:integer"/>
      <xs:attribute name="occupation" use="required" type="xs:double"/>
      <xs:attribute name="pseudo_energy" use="required" type="xs:double"/>
      <xs:attribute name="size" use="required" type="xs:integer"/>
      <xs:attribute name="type" use="required" type="xs:NCName"/>
      <xs:attribute name="ultrasoft_cutoff_radius" use="required" type="xs:double"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="PP_CHI.2">
    <xs:complexType mixed="true">
      <xs:attribute name="columns" use="required" type="xs:integer"/>
      <xs:attribute name="cutoff_radius" use="required" type="xs:double"/>
      <xs:attribute name="index" use="required" type="xs:integer"/>
      <xs:attribute name="l" use="required" type="xs:integer"/>
      <xs:attribute name="label" use="required" type="xs:NMTOKEN"/>
      <xs:attribute name="n" use="required" type="xs:integer"/>
      <xs:attribute name="occupation" use="required" type="xs:double"/>
      <xs:attribute name="pseudo_energy" use="required" type="xs:double"/>
      <xs:attribute name="size" use="required" type="xs:integer"/>
      <xs:attribute name="type" use="required" type="xs:NCName"/>
      <xs:attribute name="ultrasoft_cutoff_radius" use="required" type="xs:double"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="PP_RHOATOM">
    <xs:complexType mixed="true">
      <xs:attribute name="columns" use="required" type="xs:integer"/>
      <xs:attribute name="size" use="required" type="xs:integer"/>
      <xs:attribute name="type" use="required" type="xs:NCName"/>
    </xs:complexType>
  </xs:element>

  <!-- User-defined types -->

  <xs:simpleType name="upf-version-string">
    <xs:restriction base="xs:string">
      <xs:maxLength value="14"/>
      <xs:pattern value="[0-9\.]+"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="upf-element">
    <xs:restriction base="xs:string">
      <xs:maxLength value="2"/>
      <xs:pattern value="[A-Za-z]+"/>
      <xs:whiteSpace value="collapse"/>
    </xs:restriction>
  </xs:simpleType>
 
  <xs:simpleType name="upf-string">
    <xs:restriction base="xs:string">
      <xs:maxLength value="80"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="upf-longstring">
    <xs:restriction base="xs:string">
      <xs:maxLength value="200"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="upf-shortstring">
    <xs:restriction base="xs:string">
      <xs:maxLength value="20"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="upf-pseudotype">
    <xs:restriction base="xs:string">
      <xs:enumeration value="NC">
        <xs:annotation>
          <xs:documentation>norm-conserving</xs:documentation> 
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SL">
        <xs:annotation>
          <xs:documentation>norm-conserving (semi-local form)
          </xs:documentation> 
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="US">
        <xs:annotation>
          <xs:documentation>Vanderbilt's ultrasoft</xs:documentation> 
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PAW">
        <xs:annotation>
          <xs:documentation>Projector-Augmented Wave</xs:documentation> 
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="1/r">
        <xs:annotation>
            <xs:documentation>Coulombian 1/r potential</xs:documentation> 
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="upf-relativistic-type">
    <xs:restriction base="xs:string">
      <xs:enumeration value="no">
        <xs:annotation>
          <xs:documentation>non-relativistic calculation</xs:documentation> 
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="scalar">
        <xs:annotation>
          <xs:documentation>scalar-relativistic calculation</xs:documentation> 
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="full">
        <xs:annotation>
          <xs:documentation>full-relativistic calculation</xs:documentation> 
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="upf-logical">
    <xs:restriction base="xs:string">
      <xs:enumeration value=".true."/>
      <xs:enumeration value="T"/>
      <xs:enumeration value=".false."/>
      <xs:enumeration value="F"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="upf-data-type">
    <xs:restriction base="xs:string">
      <xs:enumeration value="character"/>
      <xs:enumeration value="logical"/>
      <xs:enumeration value="integer"/>
      <xs:enumeration value="real"/>
      <xs:enumeration value="complex"/>
    </xs:restriction>
  </xs:simpleType>
 
  <xs:complexType name="upf-data-section">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="type" use="required" type="upf-data-type"/>
        <xs:attribute name="size" use="required" type="xs:integer"/>
        <xs:attribute name="columns" use="optional" type="xs:integer"
                      default="4"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>


</xs:schema>
